grammar edu.udo.MGPL with org.eclipse.xtext.common.Terminals

generate mGPL "http://www.udo.edu/MGPL"

Prog:
	{Programm} 'game' name=ID '(' attrAssList=AttrAssList? ')' decl+=Decl* stmtBlock=StmtBlock block+=Block*
;

Decl returns Declaration:
	VarDecl ';' | ObjDecl ';'
;

VarDecl returns Declaration:
	{IntDecl} 'int' name=ID init=Init? | {IntArrayDecl} 'int' name=ID '[' size=INT ']'
;

Init: 
	'=' Expr
;

ObjDecl returns Declaration: 
	{ObjDecl} objtype=OBJTYPE name=ID '(' attrAssList=AttrAssList? ')' | {ObjArrayDecl} objtype=OBJTYPE name=ID '[' size=INT ']'
;

terminal OBJTYPE: 
	'rectangle' | 'triangle' | 'circle'
;

AttrAssList: 
    {AttributeAssignments} Assignments+=AttrAss (',' Assignments+=AttrAss)*
;

AttrAss:
	name=ID '=' expr=Expr
;

Block: 
	AnimBlock | EventBlock
;

AnimBlock: 
	{Animation} 'animation' name=ID '(' OBJTYPE objName=ID ')' stmtBlock=StmtBlock 
;

EventBlock: 
	{Event} 'on' keystroke=KEYSTROKE stmtBlock=StmtBlock 
;

terminal KEYSTROKE: 
	'space' | 'leftarrow' | 'rightarrow' | 'uparrow' | 'downarrow'
;

StmtBlock: 
	{Statements} '{' stmt+=Stmt* '}'
;

Stmt:
	IfStmt | ForStmt | AssStmt ';'
;

IfStmt: 
	{IfStatement} 'if' '(' condition=Expr ')' stmtBlockIf=StmtBlock ('else' stmtBlockElse=StmtBlock)?
;

ForStmt: 
	{ForStatement} 'for' '(' loopInitialization=AssStmt ';' loopCondition=Expr ';' loopIncrement=AssStmt ')' stmtBlock=StmtBlock 
;

AssStmt returns Declaration:
	{AssignmentStatement} var=[Declaration] '=' expr=Expr
;

Var: 
	name = [Declaration] ( '[' expr=Expr ']'('.' memberName=ID)?)? | objectName=[Declaration] '.' memberName=ID  
;

Expr returns Expression: 
	OrExpr
;

OrExpr returns Expression:
	AndExpr ({Expression.left=current} op='||' right=AndExpr)*
;

AndExpr returns Expression:
	RelExpr ({Expression.left=current} op='&&' right=RelExpr)*
;

RelExpr returns Expression:
	AddExpr ({Expression.left=current} op=('<'|'<='|'==') right=AddExpr)*
;

AddExpr returns Expression:
	MultExpr ({Expression.left=current} op=('+'|'-') right=MultExpr)*
;

MultExpr returns Expression:
	UnExpr ({Expression.left=current} op=('*'|'/') right=UnExpr)*
;

UnExpr returns Expression: 
	{Negation} op=('!'|'-') exprAtom=AtomExpr | AtomExpr
;

AtomExpr returns Expression: 
	{IntLiteral} value=INT| {Touches} left=Var (op='touches' right=Var)? | '(' Expr ')' 
;

